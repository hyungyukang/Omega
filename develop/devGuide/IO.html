<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Parallel IO (IO)</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="IO Fields (IOField)" href="IOField.html" />
    <link rel="prev" title="Metadata" href="MetaData.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            OMEGA
          </a>
              <div class="version">
                develop
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User's guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/QuickStart.html">Quick Start for Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/OmegaBuild.html">CMake-based Omega Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/DataTypes.html">Data Types and Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/MachEnv.html">Machine Environment (MachEnv)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Config.html">Model Configuration (Config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Broadcast.html">Omega Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Logging.html">Omega Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Decomp.html">Domain Decomposition (Decomp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/MetaData.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/IO.html">Parallel IO (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/IOField.html">IO Fields (IOField)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Halo.html">Halo Exchanges (Halo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/HorzMesh.html">Horizontal Mesh</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer's guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="QuickStart.html">Quick Start for Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataTypes.html">Data Types and Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataTypes.html#arrays-and-yakl">Arrays and YAKL</a></li>
<li class="toctree-l1"><a class="reference internal" href="MachEnv.html">Machine Environment (MachEnv)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Config.html">Model Configuration (Config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Broadcast.html">Omega Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="CondaEnv.html">Development Conda Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="Linting.html">Linting Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildDocs.html">Building the Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="CMakeBuild.html">Omega Build with CMake</a></li>
<li class="toctree-l1"><a class="reference internal" href="Logging.html">Developing Omega Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decomp.html">Domain Decomposition (Decomp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="MetaData.html">Metadata</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Parallel IO (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="IOField.html">IO Fields (IOField)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Halo.html">Halo Exchanges (Halo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="HorzMesh.html">Horizontal Mesh</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../design/Broadcast.html">Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Config.html">Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/DataTypes.html">DataTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Decomp.html">Decomp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Driver.html">Driver and Component Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Halo.html">Halo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Logging.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/MachEnv.html">MachineEnv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/IO.html">Input/Output (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/IOStreams.html">IOStreams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/ShallowWaterOmega0.html">Omega v0: Shallow Water</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/TimeMgr.html">TimeManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Tracers.html">Tracer infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/HorzMeshClass.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/OmegaDesignTemplate.html">Template: MyClassOrModuleName</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">OMEGA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Parallel IO (IO)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/devGuide/IO.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="parallel-io-io">
<h1>Parallel IO (IO)<a class="headerlink" href="#parallel-io-io" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>For input and output of data needed for OMEGA, we use the Software for
Caching Output and Reads for Parallel I/O
(<a class="reference external" href="https://github.com/E3SM-Project/scorpio">SCORPIO</a>) library. This
library supports parallel reading and writing of distributed arrays in various
self-describing
formats like <a class="reference external" href="https://docs.unidata.ucar.edu/netcdf/">NetCDF</a>,
<a class="reference external" href="https://www.hdfgroup.org/solutions/hdf5/">HDF5</a>,
and <a class="reference external" href="https://csmd.ornl.gov/adios">ADIOS</a>.
SCORPIO is responsible for rearranging data from the data decomposition used
for computation to a different rearrangement for parallel IO. In particular,
for optimal IO, the user would specify a different number of IO tasks than
for computation. For example, the user could specify the number of IO tasks to
match underlying hardware like the network interfaces (NICs) on a node.
Users and developers will generally access IO via
<a class="reference internal" href="#omega-user-iostreams"><span class="xref myst">IOStreams</span></a>
and other interfaces. The base IO layer described here only provides
an OMEGA-aware wrapper around SCORPIO calls.</p>
<p>The base interfaces provide functions for file operations (open/close),
reading and writing of metadata, and reading and writing of data arrays.
Interfaces at this level utilize raw pointers to data and assume
contiguous storage for arrays. SCORPIO utilizes integer handles
to various files and data types so these must often be defined or
retrieved for many operations. Although there is no IO class, we encapsulate
the IO routines within the OMEGA and IO namespaces.</p>
<p>Before using any IO functions, the parallel IO system must be initialized
using:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="n">Comm</span><span class="p">);</span>
</pre></div>
</div>
<p>where Comm is an MPI communicator and should in most cases be the communicator
from the OMEGA default MachEnv (see <a class="reference internal" href="MachEnv.html#omega-dev-mach-env"><span class="std std-ref">MachEnv</span></a>). This
function also extracts the user-defined variables from the model configuration,
include the number of IO tasks, the IO task stride, the default data
rearranger method, and the default file format
(see <a class="reference internal" href="../userGuide/IO.html#omega-user-io"><span class="std std-ref">User Guide</span></a>).</p>
<p>As mentioned above, most I/O operations will take place within the IOStreams
module, but the base IO functions can be accessed directly. To open and close
files for reading/writing, use:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">openFile</span><span class="p">(</span><span class="n">FileID</span><span class="p">,</span><span class="w"> </span><span class="n">Filename</span><span class="p">,</span><span class="w"> </span><span class="n">Mode</span><span class="p">);</span>
<span class="w">   </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">closeFile</span><span class="p">(</span><span class="n">FileID</span><span class="p">);</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">openFile</span><span class="p">(</span><span class="n">FileID</span><span class="p">,</span><span class="w"> </span><span class="n">Filename</span><span class="p">,</span><span class="w"> </span><span class="n">Mode</span><span class="p">,</span><span class="w"> </span><span class="n">Format</span><span class="p">,</span><span class="w"> </span><span class="n">IfExists</span><span class="p">,</span><span class="w"> </span><span class="n">Precision</span><span class="p">);</span>
<span class="w">   </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">closeFile</span><span class="p">(</span><span class="n">FileID</span><span class="p">);</span>
</pre></div>
</div>
<p>In both case, an integer FileID is assigned to the open file which is then
used by all subsequent operations. The Filename is a <code class="docutils literal notranslate"><span class="pre">std::string</span></code> that
should include the full path and name of the file. The mode can be either
<code class="docutils literal notranslate"><span class="pre">OMEGA::IO::ModeRead</span></code> or <code class="docutils literal notranslate"><span class="pre">OMEGA::IO::ModeWrite</span></code>. The shorter interface
uses default values for the file format, overwrite behavior and precision.
In the longer interface, the user must supply these values using the enums:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Supported file formats</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">FileFmt</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">FmtNetCDF3</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_IOTYPE_NETCDF</span><span class="p">,</span><span class="w">   </span><span class="c1">///&lt; NetCDF3 classic format</span>
<span class="w">   </span><span class="n">FmtPnetCDF</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_IOTYPE_PNETCDF</span><span class="p">,</span><span class="w">  </span><span class="c1">///&lt; Parallel NetCDF3</span>
<span class="w">   </span><span class="n">FmtNetCDF4c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_IOTYPE_NETCDF4C</span><span class="p">,</span><span class="w"> </span><span class="c1">///&lt; NetCDF4 (HDF5-compatible) cmpressed</span>
<span class="w">   </span><span class="n">FmtNetCDF4p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_IOTYPE_NETCDF4P</span><span class="p">,</span><span class="w"> </span><span class="c1">///&lt; NetCDF4 (HDF5-compatible) parallel</span>
<span class="w">   </span><span class="n">FmtNetCDF4</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_IOTYPE_NETCDF4P</span><span class="p">,</span><span class="w"> </span><span class="c1">///&lt; NetCDF4 (HDF5-compatible) parallel</span>
<span class="w">   </span><span class="n">FmtHDF5</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_IOTYPE_HDF5</span><span class="p">,</span><span class="w">     </span><span class="c1">///&lt; native HDF5 format</span>
<span class="w">   </span><span class="n">FmtADIOS</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_IOTYPE_ADIOS</span><span class="p">,</span><span class="w">    </span><span class="c1">///&lt; ADIOS format</span>
<span class="w">   </span><span class="n">FmtUnknown</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">                  </span><span class="c1">///&lt; Unknown or undefined</span>
<span class="w">   </span><span class="n">FmtDefault</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_IOTYPE_NETCDF4C</span><span class="p">,</span><span class="w"> </span><span class="c1">///&lt; NetCDF4 is default</span>
<span class="p">};</span>

<span class="c1">/// Behavior (for output files) when a file already exists</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">IfExists</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">Fail</span><span class="p">,</span><span class="w">    </span><span class="c1">/// Fail with an error</span>
<span class="w">   </span><span class="n">Replace</span><span class="p">,</span><span class="w"> </span><span class="c1">/// Replace the file</span>
<span class="w">   </span><span class="n">Append</span><span class="p">,</span><span class="w">  </span><span class="c1">/// Append to the existing file</span>
<span class="p">};</span>

<span class="c1">/// Floating point precision to allow reduced precision to save space</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Precision</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">Double</span><span class="p">,</span><span class="w"> </span><span class="c1">/// Maintain full double precision (64-bit) for reals</span>
<span class="w">   </span><span class="n">Single</span><span class="p">,</span><span class="w"> </span><span class="c1">/// Reduce all floating point variables to 32-bit reals</span>
<span class="p">};</span>
</pre></div>
</div>
<p>with the defaults for each being <code class="docutils literal notranslate"><span class="pre">IO::FmtDefault</span></code>, <code class="docutils literal notranslate"><span class="pre">IO::IfExists::Fail</span></code>,
and <code class="docutils literal notranslate"><span class="pre">IO::Precision::Double</span></code>. The E3SM standard format is currently
NetCDF4. Earlier NetCDF formats should be avoided, but are provided in
case an input file is in an earlier format. The Precision argument is
for output files only and determines whether double-precision (R8) variables
should be reduced to single precision during output.</p>
<p>Once the file is open, data is read/written using:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">readArray</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">Array</span><span class="p">,</span><span class="w"> </span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="n">VariableName</span><span class="p">,</span><span class="w"> </span><span class="n">FileID</span><span class="p">,</span><span class="w"> </span><span class="n">DecompID</span><span class="p">,</span><span class="w"> </span><span class="n">VarID</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">writeArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Array</span><span class="p">,</span><span class="w"> </span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FillValue</span><span class="p">,</span><span class="w">   </span><span class="n">FileID</span><span class="p">,</span><span class="w"> </span><span class="n">DecompID</span><span class="p">,</span><span class="w"> </span><span class="n">VarID</span><span class="p">);</span>
</pre></div>
</div>
<p>where the pointer to the data array is passed and data is assumed to be
contiguous with the full local size of the array passed as Size. The FileID is
the integer ID for the open file. The DecompID is a defined data decomposition
as described below. For reading, the variable name (as a <code class="docutils literal notranslate"><span class="pre">std::string</span></code>) is
supplied and the variable ID (VarID) is returned in case it is needed for
reading of variable metadata. For writing, a FillValue is supplied to fill
undefined locations in an array and the variable ID must have been assigned
in a prior defineVar call prior to the write as described below.</p>
<p>The IO subsystem must know how the data is laid out in the parallel
decomposition. Both the dimensions of the array and the decomposition
across tasks must be defined. For each dimension, a dimension must be
defined using:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">defineDim</span><span class="p">(</span><span class="n">FileID</span><span class="p">,</span><span class="w"> </span><span class="n">DimName</span><span class="p">,</span><span class="w"> </span><span class="n">Length</span><span class="p">,</span><span class="w"> </span><span class="n">DimID</span><span class="p">);</span>
</pre></div>
</div>
<p>where FileID is the ID of an open file, the DimName is a <code class="docutils literal notranslate"><span class="pre">std::string</span></code>
with the dimension name (eg NCells, NEdges, NVertices, NVertLevels or
NTracers), length is the length of the full global array and DimID is
the ID assigned to this dimension. Note that for reading a file, we
do have a function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">Length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">getDimLength</span><span class="p">(</span><span class="n">FileID</span><span class="p">,</span><span class="w"> </span><span class="n">DimName</span><span class="p">);</span>
</pre></div>
</div>
<p>that can be used to inquire about the dimension length and check for
consistency, but the full dimension must still be defined.</p>
<p>Once the dimensions are defined, the decomposition of an array must
be defined using:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createDecomp</span><span class="p">(</span><span class="n">DecompID</span><span class="p">,</span><span class="w"> </span><span class="n">IODataType</span><span class="p">,</span><span class="w"> </span><span class="n">NDims</span><span class="p">,</span><span class="w"> </span><span class="n">DimLengths</span><span class="p">,</span>
<span class="w">                          </span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="n">GlobalIndx</span><span class="p">,</span><span class="w"> </span><span class="n">Rearr</span><span class="p">);</span>
</pre></div>
</div>
<p>where DecompID is the ID assigned to the newly created decomposition,
NDims is the number of dimensions for the array, DimLengths is an
integer <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of the NDims local dimension lengths, Size is the
full size of the local array, and Rearr is the data rearranger method
to use to map to the number of IO tasks. The Rearr can be set to
<code class="docutils literal notranslate"><span class="pre">OMEGA::IO::DefaultRearr</span></code> to make use of the overall default defined
when the IO system was initialized, but can also be set explicitly to
<code class="docutils literal notranslate"><span class="pre">OMEGA::IO::RearrBox</span></code> or <code class="docutils literal notranslate"><span class="pre">OMEGA::IO::RearrSubset</span></code>. The box rearranger
is generally preferred (see <a class="reference internal" href="../userGuide/IO.html#omega-user-io"><span class="std std-ref">UserGuide</span></a>). The GlobalIndx
array describes the global location (as a zero-based offset) of each
local array entry. This can be computed from the OMEGA Default Decomp
arrays. For example, an array dimensioned (NCellsAll,NVertLevels) would
have an offset computed using:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OffsetCell</span><span class="p">(</span><span class="n">NCellsAll</span><span class="o">*</span><span class="n">NVertLevels</span><span class="p">,</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Cell</span><span class="p">;</span><span class="w"> </span><span class="n">Cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">Cell</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NCellsOwned</span><span class="p">){</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NVertLevels</span><span class="p">){</span>
<span class="w">         </span><span class="n">OffsetCell</span><span class="p">[</span><span class="n">Add</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">CellIDH</span><span class="p">(</span><span class="n">Cell</span><span class="p">)</span><span class="mi">-1</span><span class="p">)</span><span class="o">*</span><span class="n">NVertLevels</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">         </span><span class="n">Add</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span>
</pre></div>
</div>
<p>Note that we exclude Halo layers by assigning an offset of -1. Finally,
the data type of the array must be supplied. To map the standard OMEGA
data types to the data types used in the IO subsystem, we define:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">IODataType</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">IOTypeI4</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_INT</span><span class="p">,</span><span class="w">    </span><span class="c1">/// 32-bit integer</span>
<span class="w">   </span><span class="n">IOTypeI8</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_INT64</span><span class="p">,</span><span class="w">  </span><span class="c1">/// 64-bit integer</span>
<span class="w">   </span><span class="n">IOTypeR4</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_REAL</span><span class="p">,</span><span class="w">   </span><span class="c1">/// 32-bit real</span>
<span class="w">   </span><span class="n">IOTypeR8</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_DOUBLE</span><span class="p">,</span><span class="w"> </span><span class="c1">/// 64-bit real</span>
<span class="w">   </span><span class="n">IOTypeChar</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_CHAR</span><span class="p">,</span><span class="w">   </span><span class="c1">/// Character/string</span>
<span class="w">   </span><span class="n">IOTypeLogical</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIO_INT</span><span class="w">     </span><span class="c1">/// Logicals are converted to ints for IO</span>
<span class="p">};</span>
</pre></div>
</div>
<p>so that in the above interface, we would supply for example <code class="docutils literal notranslate"><span class="pre">IO::IOTypeI4</span></code>
for an OMEGA I4 data type.</p>
<p>Now that dimensions and decompositions have been defined, a variable can
be defined (this is required for writing only) using:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">defineVar</span><span class="p">(</span><span class="n">FileID</span><span class="p">,</span><span class="w"> </span><span class="n">VarName</span><span class="p">,</span><span class="w"> </span><span class="n">IODataType</span><span class="p">,</span><span class="w"> </span><span class="n">NDims</span><span class="p">,</span><span class="w"> </span><span class="n">DimIDs</span><span class="p">,</span><span class="w"> </span><span class="n">VarID</span><span class="p">);</span>
</pre></div>
</div>
<p>where VarID is the ID assigned to the variable, FileID is the usual ID of
the data file, VarName is a <code class="docutils literal notranslate"><span class="pre">std::string</span></code> holding the variable name,
IODataType is the data type described above, NDims are the number of dimensions,
and DimIDs are an integer <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> holding the dimension IDs for each
dimension. The variable ID can then be used in all IO calls related to this
variable.</p>
<p>In addition to data in a file, we can also read and write metadata. As with
the data itself, metadata is typically managed by the IOStreams and Metadata
interfaces, but the base IO module contains interfaces for reading and
writing metadata associated with either an array or the file or simulation
itself. To read/write metadata, use:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">writeMeta</span><span class="p">(</span><span class="n">MetaName</span><span class="p">,</span><span class="w"> </span><span class="n">MetaValue</span><span class="p">,</span><span class="w"> </span><span class="n">FileID</span><span class="p">,</span><span class="w"> </span><span class="n">VarID</span><span class="p">);</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IO</span><span class="o">::</span><span class="n">readMeta</span><span class="w"> </span><span class="p">(</span><span class="n">MetaName</span><span class="p">,</span><span class="w"> </span><span class="n">MetaValue</span><span class="p">,</span><span class="w"> </span><span class="n">FileID</span><span class="p">,</span><span class="w"> </span><span class="n">VarID</span><span class="p">);</span>
</pre></div>
</div>
<p>where MetaName is a <code class="docutils literal notranslate"><span class="pre">std::string</span></code> holding the name of the metadata and
the MetaValue is the value of the MetaData. All supported OMEGA data types are
allowed except boolean which must be converted to an integer type. The FileID
is once again the ID of the open data file and VarID is the variable to which
this metadata is attached. For global file and simulation metadata not attached
to a variable, the ID <code class="docutils literal notranslate"><span class="pre">IO::GlobalID</span></code> is used to denote global metadata.</p>
<p>For an example of the full read/write process, the IO unit test contains
the full reading and writing of a data file and associated metadata. We
will repeat again that users and developers are not expected to learn and
use the interfaces above, but should access the IO system from the IOStreams
interfaces.</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="MetaData.html" class="btn btn-neutral float-left" title="Metadata" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="IOField.html" class="btn btn-neutral float-right" title="IO Fields (IOField)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Energy Exascale Earth System Model Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>