<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Auxiliary variables</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="TimeManager" href="TimeMgr.html" />
    <link rel="prev" title="State" href="State.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            OMEGA
          </a>
              <div class="version">
                develop
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User's guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/QuickStart.html">Quick Start for Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/OmegaBuild.html">CMake-based Omega Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/DataTypes.html">Data Types and Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/MachEnv.html">Machine Environment (MachEnv)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Config.html">Model Configuration (Config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Broadcast.html">Omega Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Logging.html">Omega Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Decomp.html">Domain Decomposition (Decomp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/MetaData.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/IO.html">Parallel IO (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/IOField.html">IO Fields (IOField)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Halo.html">Halo Exchanges (Halo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/HorzMesh.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/HorzOperators.html">Horizontal Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/AuxiliaryVariables.html">Auxiliary Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TendencyTerms.html">Tendency Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TimeMgr.html">Time Manager (TimeMgr)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Reductions.html">Global Reductions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer's guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/QuickStart.html">Quick Start for Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/CondaEnv.html">Development Conda Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Linting.html">Linting Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/BuildDocs.html">Building the Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/DataTypes.html">Data Types and Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/DataTypes.html#arrays-and-kokkos">Arrays and Kokkos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/MachEnv.html">Machine Environment (MachEnv)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Config.html">Model Configuration (Config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Broadcast.html">Omega Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/CMakeBuild.html">Omega Build with CMake</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Logging.html">Developing Omega Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Decomp.html">Domain Decomposition (Decomp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/MetaData.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/IO.html">Parallel IO (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/IOField.html">IO Fields (IOField)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Halo.html">Halo Exchanges (Halo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/HorzMesh.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/HorzOperators.html">Horizontal Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/AuxiliaryVariables.html">Auxiliary Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/TendencyTerms.html">Tendency Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/TimeMgr.html">Time Manager (TimeMgr)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Reductions.html">Global Reductions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design documents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Broadcast.html">Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="Config.html">Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataTypes.html">DataTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decomp.html">Decomp</a></li>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">Driver and Component Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Halo.html">Halo</a></li>
<li class="toctree-l1"><a class="reference internal" href="HorzMeshClass.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="Logging.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="MachEnv.html">MachineEnv</a></li>
<li class="toctree-l1"><a class="reference internal" href="Metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO.html">Input/Output (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="IOStreams.html">IOStreams</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="ShallowWaterOmega0.html">Omega v0: Shallow Water</a></li>
<li class="toctree-l1"><a class="reference internal" href="State.html">State</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Auxiliary variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">1 Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#requirements">2 Requirements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#requirement-functions-that-compute-auxiliary-variables-should-have-simple-intuitive-calling-arguments">2.1 Requirement: Functions that compute auxiliary variables should have simple, intuitive calling arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-auxiliary-variables-computations-should-be-able-to-be-grouped-under-different-outer-loops-over-mesh-locations">2.2 Requirement: Auxiliary variables computations should be able to be grouped under different outer loops over mesh locations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-vectorization-on-cpu-architectures">2.3 Requirement: Vectorization on CPU architectures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-configuration-options">2.4 Requirement: Configuration options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-output">2.5 Requirement: Output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#desired-small-memory-footprint">2.6 Desired: Small memory footprint</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#algorithmic-formulation">3 Algorithmic Formulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#design">4 Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-types-and-parameters">4.1 Data types and parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parameters">4.1.1 Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-structs-data-types">4.1.2 Class/structs/data types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#methods">4.2 Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constructor">4.2.1 Constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compute-methods">4.2.2 Compute methods</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#verification-and-testing">5 Verification and Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#unit-testing">5.1 Unit testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#convergence-testing">5.2 Convergence testing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="TimeMgr.html">TimeManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timers.html">Timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepping.html">Time Stepping</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tracers.html">Tracer infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="OmegaDesignTemplate.html">Template: MyClassOrModuleName</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">OMEGA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Auxiliary variables</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/design/AuxiliaryVariables.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="auxiliary-variables">
<span id="omega-design-auxvars"></span><h1>Auxiliary variables<a class="headerlink" href="#auxiliary-variables" title="Permalink to this heading"></a></h1>
<section id="overview">
<h2>1 Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>Auxiliary variables are variables that are needed to compute the tendency terms
and advance the model state. While they are functions of the model state, they
differ from variables needed only for diagnostic purposes. Auxiliary variables
can often be bundled together into groups of variables that are logically
related, or can be efficiently computed together. Each auxiliary variable group
is implemented as a class containing array(s) storing the variable(s) and member
functions that compute them. The member functions compute the variable (or
variable group) over a chunk of vertical levels for a particular mesh location.
There may be more than one compute function, since some groups may contain
variables defined on different mesh elements. This approach allows flexible
groupings of computational work within larger cell/edge/vertex loops. This type
of flexibility will be important for optimizing the code across different device
architectures.</p>
</section>
<section id="requirements">
<h2>2 Requirements<a class="headerlink" href="#requirements" title="Permalink to this heading"></a></h2>
<section id="requirement-functions-that-compute-auxiliary-variables-should-have-simple-intuitive-calling-arguments">
<h3>2.1 Requirement: Functions that compute auxiliary variables should have simple, intuitive calling arguments<a class="headerlink" href="#requirement-functions-that-compute-auxiliary-variables-should-have-simple-intuitive-calling-arguments" title="Permalink to this heading"></a></h3>
<p>Auxiliary variables take in constant data as constructor arguments, which
simplifies the arguments used to call the compute methods.</p>
</section>
<section id="requirement-auxiliary-variables-computations-should-be-able-to-be-grouped-under-different-outer-loops-over-mesh-locations">
<h3>2.2 Requirement: Auxiliary variables computations should be able to be grouped under different outer loops over mesh locations<a class="headerlink" href="#requirement-auxiliary-variables-computations-should-be-able-to-be-grouped-under-different-outer-loops-over-mesh-locations" title="Permalink to this heading"></a></h3>
<p>The ability to fuse/separate auxiliary variables computations will allow for
optimization across different device architectures. Member functions will
implement a given variable (group) computation on a specific mesh location
(cell, edge, vertex).</p>
</section>
<section id="requirement-vectorization-on-cpu-architectures">
<h3>2.3 Requirement: Vectorization on CPU architectures<a class="headerlink" href="#requirement-vectorization-on-cpu-architectures" title="Permalink to this heading"></a></h3>
<p>Auxiliary variables computations have inner loops over a chunk of vertical
levels. The chunk size will be set to the vector length on CPU machines and 1
for GPUs. This will allow for the possibility of vectorization on CPUs.</p>
</section>
<section id="requirement-configuration-options">
<h3>2.4 Requirement: Configuration options<a class="headerlink" href="#requirement-configuration-options" title="Permalink to this heading"></a></h3>
<p>Some auxiliary variables need to be computed differently based on configuration
options. The class constructor will retrieve possible options from the Config
and store them as enums. The compute functions will do different things based on
the stored options.</p>
</section>
<section id="requirement-output">
<h3>2.5 Requirement: Output<a class="headerlink" href="#requirement-output" title="Permalink to this heading"></a></h3>
<p>Auxiliary variables can also be useful as diagnostics. Each class will have a
method to register the variables with IOStreams to provide diagnostic output.</p>
</section>
<section id="desired-small-memory-footprint">
<h3>2.6 Desired: Small memory footprint<a class="headerlink" href="#desired-small-memory-footprint" title="Permalink to this heading"></a></h3>
<p>Some auxiliary variables are used only to compute another auxiliary variable,
and are not needed afterwards. It may be desirable to find a memory management
strategy that would allow to minimize the amount of persistent memory needed.</p>
</section>
</section>
<section id="algorithmic-formulation">
<h2>3 Algorithmic Formulation<a class="headerlink" href="#algorithmic-formulation" title="Permalink to this heading"></a></h2>
<p>The algorithmic formulation for each auxiliary variable can be found in the
algorithms design document.</p>
</section>
<section id="design">
<h2>4 Design<a class="headerlink" href="#design" title="Permalink to this heading"></a></h2>
<section id="data-types-and-parameters">
<h3>4.1 Data types and parameters<a class="headerlink" href="#data-types-and-parameters" title="Permalink to this heading"></a></h3>
<section id="parameters">
<h4>4.1.1 Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading"></a></h4>
<p>Each configurable auxiliary variable will define its parameters as an enum. Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">FluxThickType</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Center</span><span class="p">,</span><span class="w"> </span><span class="n">Upwind</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>These parameters will be read from the input configuration file</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="nt">advection</span><span class="p">:</span>
<span class="w">       </span><span class="nt">fluxThicknessType</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;Center&#39;</span>
</pre></div>
</div>
<p>and stored inside the class.</p>
</section>
<section id="class-structs-data-types">
<h4>4.1.2 Class/structs/data types<a class="headerlink" href="#class-structs-data-types" title="Permalink to this heading"></a></h4>
<p>The auxiliary variables group is a class that contains arrays for storing the
variables and methods to compute them. Configuration choices will also be
stored. The class also contains private member variables for any constant data
that are defined by the constructor.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LayerThicknessAuxVars</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">   </span><span class="n">Array2DReal</span><span class="w"> </span><span class="n">FluxLayerThickEdge</span><span class="p">;</span>
<span class="w">   </span><span class="n">Array2DReal</span><span class="w"> </span><span class="n">MeanLayerThickEdge</span><span class="p">;</span>
<span class="w">   </span><span class="n">FluxThickType</span><span class="w"> </span><span class="n">FluxThickChoice</span><span class="p">;</span>

<span class="w">   </span><span class="n">KOKKOS_FUNCTION</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">computeVarsOnEdge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">KChunk</span><span class="p">,</span>
<span class="w">                                          </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">LayerThickness</span><span class="p">,</span>
<span class="w">                                          </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">NormalVelocity</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">   </span><span class="n">Array2DI4</span><span class="w"> </span><span class="n">CellsOnEdge</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="methods">
<h3>4.2 Methods<a class="headerlink" href="#methods" title="Permalink to this heading"></a></h3>
<section id="constructor">
<h4>4.2.1 Constructor<a class="headerlink" href="#constructor" title="Permalink to this heading"></a></h4>
<p>The constructor will be responsible for:</p>
<ul class="simple">
<li><p>allocating auxiliary variables</p></li>
<li><p>retrieving and storing the configuration options if applicable</p></li>
<li><p>registering fields and metadata with the I/O infrastructure.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="n">LayerThicknessAuxVars</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">HorzMesh</span><span class="w"> </span><span class="o">*</span><span class="n">mesh</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NVertLevels</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Config</span><span class="w"> </span><span class="o">*</span><span class="n">Options</span><span class="p">)</span>
<span class="w">       </span><span class="o">:</span><span class="w"> </span><span class="n">FluxLayerThickEdge</span><span class="p">(</span><span class="s">&quot;FluxLayerThickEdge&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">NEdgesSize</span><span class="p">,</span>
<span class="w">                            </span><span class="n">NVertLevels</span><span class="p">),</span>
<span class="w">         </span><span class="n">MeanLayerThickEdge</span><span class="p">(</span><span class="s">&quot;MeanLayerThickEdge&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">NEdgesSize</span><span class="p">,</span>
<span class="w">                            </span><span class="n">NVertLevels</span><span class="p">),</span>
<span class="w">         </span><span class="n">CellsOnEdge</span><span class="p">(</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">CellsOnEdge</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">             </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">FluxThickTypeStr</span><span class="p">;</span>
<span class="w">             </span><span class="n">Config</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;fluxThicknessType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">FluxThickTypeStr</span><span class="p">);</span>
<span class="w">             </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">FluxThickTypeStr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                 </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;Center&quot;</span><span class="p">:</span>
<span class="w">                 </span><span class="n">FluxThickType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Center</span><span class="p">;</span>
<span class="w">                 </span><span class="k">break</span><span class="p">;</span>
<span class="w">                 </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;Upwind&quot;</span><span class="p">:</span>
<span class="w">                 </span><span class="n">FluxThickType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Upwind</span><span class="p">;</span>
<span class="w">                 </span><span class="k">break</span><span class="p">;</span>
<span class="w">                 </span><span class="k">default</span><span class="o">:</span>
<span class="w">                 </span><span class="n">FluxThickType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Upwind</span><span class="p">;</span>
<span class="w">                 </span><span class="k">break</span><span class="p">;</span>
<span class="w">             </span><span class="p">}</span>

<span class="w">             </span><span class="n">defineIOFields</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="compute-methods">
<h4>4.2.2 Compute methods<a class="headerlink" href="#compute-methods" title="Permalink to this heading"></a></h4>
<p>Compute methods implement the auxiliary variables computations for a chunk of
vertical levels at a given horizontal mesh location. The mesh location is
indicated in the method name. There may be more than one compute method to
compute different groups of variables over different mesh locations. Any
configurable computation options are handled inside the compute method. The
inner loop over a chunk of vertical levels enables CPU vectorization.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="n">KOKKOS_FUNCTION</span><span class="w"> </span><span class="kt">void</span>
<span class="w">   </span><span class="n">computeVarsOnEdge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">KChunk</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">LayerThickCell</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">NormalVelEdge</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">KStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KChunk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">JCell0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CellsOnEdge</span><span class="p">(</span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">JCell1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CellsOnEdge</span><span class="p">(</span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">KVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">KVec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">KVec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">KVec</span><span class="p">;</span>
<span class="w">         </span><span class="n">MeanLayerThickEdge</span><span class="p">(</span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">             </span><span class="mf">0.5</span><span class="n">_Real</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">LayerThickCell</span><span class="p">(</span><span class="n">JCell0</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">LayerThickCell</span><span class="p">(</span><span class="n">JCell1</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">));</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">FluxThickEdgeChoice</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">Center</span><span class="p">:</span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">KVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">KVec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">KVec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">KVec</span><span class="p">;</span>
<span class="w">            </span><span class="n">FluxLayerThickEdge</span><span class="p">(</span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">                </span><span class="mf">0.5</span><span class="n">_Real</span><span class="w"> </span><span class="o">*</span>
<span class="w">                </span><span class="p">(</span><span class="n">LayerThickCell</span><span class="p">(</span><span class="n">JCell0</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">LayerThickCell</span><span class="p">(</span><span class="n">JCell1</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">));</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">Upwind</span><span class="p">:</span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">KVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">KVec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">KVec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">KVec</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">NormalVelEdge</span><span class="p">(</span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">               </span><span class="n">FluxLayerThickEdge</span><span class="p">(</span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LayerThickCell</span><span class="p">(</span><span class="n">JCell0</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">NormalVelEdge</span><span class="p">(</span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">               </span><span class="n">FluxLayerThickEdge</span><span class="p">(</span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LayerThickCell</span><span class="p">(</span><span class="n">JCell1</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">               </span><span class="n">FluxLayerThickEdge</span><span class="p">(</span><span class="n">IEdge</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">max</span><span class="p">(</span>
<span class="w">                   </span><span class="n">LayerThickCell</span><span class="p">(</span><span class="n">JCell0</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">),</span><span class="w"> </span><span class="n">LayerThickCell</span><span class="p">(</span><span class="n">JCell1</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="verification-and-testing">
<h2>5 Verification and Testing<a class="headerlink" href="#verification-and-testing" title="Permalink to this heading"></a></h2>
<section id="unit-testing">
<h3>5.1 Unit testing<a class="headerlink" href="#unit-testing" title="Permalink to this heading"></a></h3>
<p>Each auxiliary variable will be used in a CTest which will compare its result
against a reference value.</p>
</section>
<section id="convergence-testing">
<h3>5.2 Convergence testing<a class="headerlink" href="#convergence-testing" title="Permalink to this heading"></a></h3>
<p>The auxiliary variables for the shallow water equations will be tested on
existing test cases implemented in Polaris to verify they produce the correct
convergence rates.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="State.html" class="btn btn-neutral float-left" title="State" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="TimeMgr.html" class="btn btn-neutral float-right" title="TimeManager" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Energy Exascale Earth System Model Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>